<<<<<<< HEAD
library(rjags)
library(parallel)  ####this needs to be parallel###
library(boot)
###set working directory###
#setwd("/Users/mohammadi02/Desktop/EffToxSIM")
###number of simulations###
n_sim <- 1000
###indicator of whether or not outcomes are treated as time-to-event variables###
###all_data = 0 implies time-to-event, all_data = 1 implies binary outcomes###
all_data <- 0
###maximum sample size/cohorts###
max_n       <- 21
cohort_size <- 3
wait_time   <- 2
dec_n       <- 20
###assign the dose levels###
dose_level <- 1:4
###time in weeks when survival or toxicity is measured###
surv_T <- 24
tox_T  <- 4
a      <- 1 # Shape 1 parameter for the beta distribution to simulate survival and toxicty time
###true probabilities of efficacy and toxicity###
=======
binconf
rep("-", 80)
paste(rep("-", 80), collapse = "")
paste(rep("#", 80), collapse = "")
Pool <- function(d.esl, d.exp, t.esl, t.exp){
d.pool <- c(d.esl, d.exp)
t.pool <- c(t.esl, t.exp)
s.conf <- binconf(sum(1-d.pool),length(1-d.pool), method = "wilson")[2:3]
t.conf <- binconf(sum(t.pool),length(t.pool), method = "wilson")[2:3]
pooled <- c(mean(1-d.pool), s.conf, mean(t.pool), t.conf)
return(pooled)
}
RaoBlackwell <- function(d.esl, d.exp, t.esl, t.exp, dose, optimal_dose,
tox_time_obs, surv_time_obs){
# Length of death & toxicity indicators for the optimal_dose
m <- length(d.esl[dose == optimal_dose])
# Combined escalation and expansion death & toxicity vectors
d.all <- c(d.esl[dose == optimal_dose], d.exp)
t.all <- c(t.esl[dose == optimal_dose], t.exp)
# Of all possible permutations of death indicator, a random sample (of size q)
# of the combined escalation & expansion
# is taken of size (m + expansion size)
q <- 100
d.perm <- t(replicate(n = q, d.all[sample(1:length(d.all), replace=FALSE)]))
t.perm <- t(replicate(n = q, t.all[sample(1:length(t.all), replace=FALSE)]))
## Non-parametric Bootsrap: We will resample each permutation with replacement
## from the observed data from
## both the escalation trial and follow-up cohort. The quantiles for the
## distribution will be used for CI
# d.npb <- lapply(1:q, function(i) replicate(n = q, d.perm[i,][sample(1:length(d.perm[i,]), replace = TRUE)]))
# t.npb <- lapply(1:q, function(i) replicate(n = q, t.perm[i,][sample(1:length(t.perm[i,]), replace = TRUE)]))
# cov <- matrix(NA, ncol = 4, nrow = q)
# for (k in 1:q){
# # Obtain each resampled matrix of death and toxicity indicators
# d.resamp <- t(d.npb[[k]])
# t.resamp <- t(t.npb[[k]])
# # Replace the resamples for the optimal dose with the original doses (for toxicity and survival)
# d.list <- t(sapply(1:q, function(i) replace(x = d.esl, dose == optimal_dose, d.resamp[i, 1:m])))
# t.list <- t(sapply(1:q, function(i) replace(x = t.esl, dose == optimal_dose, t.resamp[i, 1:m])))
# # Rerun samples through dose model to find optimal dose
# dose.mod <- sapply(1:q, function(i) DOSE.MODEL(d.list[i,], t.list[i,], dose, tox_time_obs, surv_time_obs))
# s.new <- sapply(1:q, function(i) ifelse(dose.mod[i] == optimal_dose, 1 - mean(d.list[i, m:length(d.list[i,])]), NA))
# t.new <- sapply(1:q, function(i) ifelse(dose.mod[i] == optimal_dose, mean(t.list[i, m:length(t.list[i,])]), NA))
# s.cov <- quantile(s.new, c(0.025, 0.975), na.rm = T)
# t.cov <- quantile(t.new, c(0.025, 0.975), na.rm = T)
# cov[k,] <- c(s.cov, t.cov)
# }
# Replace the new permuted death indicators for optimal dose with the orignal doses (for toxicity and survival)
d.mat <- t(sapply(1:q, function(i) replace(x = d.esl, dose == optimal_dose, d.perm[i,1:m])))
t.mat <- t(sapply(1:q, function(i) replace(x = t.esl, dose == optimal_dose, t.perm[i,1:m])))
# Using the dose.model function, input the death vector and toxicity vector for each q random permutation
dose.update <- sapply(1:q, function(i) DOSE.MODEL(d.mat[i,],t.mat[i,], dose, tox_time_obs, surv_time_obs))
# Conditional UMVUE: Expectation of the sample proportion using the optimal dose expansion data conditional on
# the permuted death outcomes for the optimal dose (escalation and expansion) and the refit model choosing
# the optimal dose.
s.rb <- sapply(1:q, function(i) ifelse(dose.update[i]==optimal_dose, 1 - mean(d.perm[i, m:length(d.perm[i,])]), NA))
t.rb <- sapply(1:q, function(i) ifelse(dose.update[i]==optimal_dose, mean(t.perm[i, m:length(t.perm[i,])]), NA))
RB.est <- c(mean(s.rb , na.rm=TRUE), mean(t.rb , na.rm=TRUE))
return(RB.est)
}
DOSE.MODEL <- function(death, tox, dose, tox_time_obs, surv_time_obs) {
# Set total subjects to 21 subjects
total_subjects <- max_n
# Indicator for each possible scenario of death and tox (e.g. 1 is for death = 1 and tox = 1)
scenario <- 1 * (death == 1 & tox == 1) + 2 * (death == 1 & tox == 0) + 3 * (death == 0 & tox == 1) + 4 * (death == 0 & tox == 0)
###update model ###
jags_works <- 0
attempt <- 1
while(jags_works == 0) {
jags_mod <- try(jags.model(	'survEffTox_revision_unif2.bug',
data = list('scenario' = scenario[1:total_subjects], 'dose' = dose[1:total_subjects], 'N' = total_subjects,
'y_s' = surv_time_obs[1:total_subjects], 'h_s' = surv_T, 'y_t' = tox_time_obs[1:total_subjects], 'h_t' = tox_T,
'beta0t_m' = beta0t_m, 'beta1t_m' = beta1t_m, 'beta0s_m' = beta0s_m, 'beta1s_m' = beta1s_m, 'beta2s_m' = beta2s_m,
'beta0t_p' = beta0t_p, 'beta1t_p' = beta1t_p, 'beta0s_p' = beta0s_p, 'beta1s_p' = beta1s_p,
'beta2s_p' = beta2s_p, 'ones' = rep(1, total_subjects)),
init = list('beta0t' = -2, 'beta1t' = 1, 'beta0s' = -1, 'beta1s' = 1, 'beta2s' = 0),
n.chains = 1, quiet = TRUE))
jags_works <- 1*(length(jags_mod) > 1 | attempt == 10)
attempt <- attempt + 1
}
update(jags_mod, 4000, quiet = TRUE)
coda_samples_temp <- coda.samples(jags_mod, c('pt_est', 'ps_est'), 1000, quiet = TRUE)
##coda_samples_temp <- coda.samples(jags_mod, c('pt_est', 'ps_est', 'beta0t', 'beta1t', 'beta0s', 'beta1s', 'beta2s'), 1000)
coda_samples <- coda_samples_temp[[1]]
dist_samples <- matrix(data = 0, ncol = dim(coda_samples)[2]/2, nrow = dim(coda_samples)[1])
for(k in 1:dim(dist_samples)[2]) {
dist_samples[,k] <- calc_dist(ps = coda_samples[,k], pt = coda_samples[,(k + 4)])
}
###prob_ps_g_psmin is the posterior probability that the probability of survival is greater than ps_min###
###prob_pt_l_ptmax is the posterior probability that the probability of toxicity is less than pt_max###
prob_acceptable <- colMeans(dist_samples > 0)
###determine acceptable doses###
acceptable <- 1*(prob_acceptable > gatekeeper)
accept_dose <- dose_level[acceptable  == 1]
###Calculate desirability index for acceptable doses###
ps_cur <- colMeans(coda_samples[,1:4])
pt_cur <- colMeans(coda_samples[,5:8])
dist_cur <- calc_dist(ps_cur[acceptable  == 1], pt_cur[acceptable  == 1])
###identify optimal dose ###
optimal_dose.perm <- accept_dose[which.max(dist_cur)]
return(optimal_dose.perm)
}
BetaComP <- function(d.esl, d.exp, t.esl, t.exp, optimal_dose, dose, surv_time_obs, tox_time_obs){
#
if(mean(d.exp)==0){
Beta.est <- rep(NA, 6)
} else {
# Beta commensurate prior
scenario <- 1 * (d.esl == 1 & t.esl == 1) + 2 * (d.esl == 1 & t.esl == 0) + 3 * (d.esl == 0 & t.esl == 1) + 4 * (d.esl == 0 & t.esl == 0)
jags_works <- 0
attempt <- 1
total_subjects <- max_n
N2 <- dec_n
while(jags_works == 0) {
comensurate_data <- list('op_dose' =  optimal_dose, 'v.e' = 0.5, 'l.slab.e' = 1, 'u.slab.e' = 4, 'spike.e' = 400, 'v.t' = 0.5, 'l.slab.t' = 1, 'u.slab.t' = 2.25, 'spike.t' = 100, 'N2' = N2, 'surv.exp'=1-d.exp, 'tox.exp'=t.exp, 'scenario' = scenario[1:total_subjects], 'dose' = dose[1:total_subjects], 'N' = total_subjects, 'y_s' = surv_time_obs[1:total_subjects], 'h_s' = surv_T, 'y_t' = tox_time_obs[1:total_subjects], 'h_t' = tox_T, 'beta0t_m' = beta0t_m, 'beta1t_m' = beta1t_m, 'beta0s_m' = beta0s_m, 'beta1s_m' = beta1s_m, 'beta2s_m' = beta2s_m, 'beta0t_p' = beta0t_p, 'beta1t_p' = beta1t_p, 'beta0s_p' = beta0s_p, 'beta1s_p' = beta1s_p,'beta2s_p' = beta2s_p, 'ones' = rep(1, total_subjects))
jags_mod.2 <- try(jags.model('commensurate_model_beta2.bug', data = comensurate_data,init = list('beta0t' = -2, 'beta1t' = 1, 'beta0s' = -1, 'beta1s' = 1, 'beta2s' = 0),
n.chains = 1, quiet = TRUE))
jags_works <- 1*(length(jags_mod.2) > 1 | attempt == 10)
attempt <- attempt + 1
}
update(jags_mod.2, 4000, quiet = TRUE)
coda_samples_temp.2 <- coda.samples(jags_mod.2, c('exp_eff', 'exp_tox'),1000, quiet = TRUE)
coda_samples.2 <- coda_samples_temp.2[[1]]
# Beta Commensurate prior data
ps_est <- mean(coda_samples.2[,1])
pt_est <- mean(coda_samples.2[,2])
ps_conf <- quantile(coda_samples.2[,1], c(0.025, 0.975))
pt_conf <- quantile(coda_samples.2[,2], c(0.025, 0.975))
Beta.est <- c(ps_est, ps_conf, pt_est, pt_conf)
}
return(Beta.est)
}
ESTIMATORS <- function(d.esl, d.exp, t.esl, t.exp, optimal_dose, dose,
surv_time_obs, tox_time_obs, mb){
if (optimal_dose != 0){
# EXPANSION ESTIMATES ONLY
s.dec <- mean(1-d.exp)
t.dec <- mean(t.exp)
s.conf <- binconf(sum(1-d.exp), length(1-d.exp), method = "wilson")[2:3]
t.conf <- binconf(sum(t.exp), length(t.exp), method = "wilson")[2:3]
dec <- c(s.dec, s.conf, t.dec, t.conf)
# POOLED ESTIMATES
pooled <- Pool(d.esl, d.exp, t.esl, t.exp)
# RAO-BLACKWELL ESTIMATES
rb.est <- RaoBlackwell(d.esl, d.exp, t.esl, t.exp, dose, optimal_dose, tox_time_obs, surv_time_obs)
# BETA COMMENSURATE PRIOR ESTIMATES
bc.est <- BetaComP(d.esl, d.exp, t.esl, t.exp, optimal_dose, dose, surv_time_obs, tox_time_obs)
# ESCALATION ESTIMATES ONLY
s.escl <- mean(1 - d.esl)
t.escl <- mean(t.esl)
s.escl_conf <- binconf(sum(1 - d.esl), length(1 - d.esl), method = "wilson")[2:3]
t.escl_conf <- binconf(sum(t.esl), length(t.esl), method = "wilson")[2:3]
esl.est <- c(s.escl, s.escl_conf, t.escl, t.escl_conf)
# MODEL-BASED ESTIMATES (EffTox estimates and respective CI are from SurvEffTox_sim)
mb.est <- mb
# MEM MODEL ESTIMATES
#mem.mat <- sapply(seq(0.01, 1, by = 0.01), function(i) MEM.data(1-d.esl,1-d.exp, t.esl, t.exp, dose, optimal_dose,i))
} else {
dec <- rep(NA, 6)
pooled <- rep(NA, 6)
rb.est <- rep(NA, 2)
bc.est <- rep(NA, 6)
esl.est <- rep(NA, 6)
mb.est <- rep(NA, 6)
#mem.mat <- matrix(NA, ncol = 100, nrow = 2)
}
return(c(optimal_dose, dec, pooled, rb.est, bc.est, esl.est, mb.est))
}
EstiResults <- function(sim_results, n_sim = 1000){
optimal_dose <- sapply(1:n_sim, function(i) sim_results1[[i]]$dat[1])
d.esl <- sapply(1:n_sim, function(i) sim_results[[i]]$death)
t.esl <- sapply(1:n_sim, function(i) sim_results[[i]]$tox)
d.exp1 <- sapply(1:n_sim, function(i) sim_results[[i]]$dec$d1)
t.exp1 <- sapply(1:n_sim, function(i) sim_results[[i]]$dec$t1)
d.exp2 <- sapply(1:n_sim, function(i) sim_results[[i]]$dec$d2)
t.exp2 <- sapply(1:n_sim, function(i) sim_results[[i]]$dec$t2)
d.exp3 <- sapply(1:n_sim, function(i) sim_results[[i]]$dec$d3)
t.exp3 <- sapply(1:n_sim, function(i) sim_results[[i]]$dec$t3)
d.exp4 <- sapply(1:n_sim, function(i) sim_results[[i]]$dec$d4)
t.exp4 <- sapply(1:n_sim, function(i) sim_results[[i]]$dec$t4)
dose <- sapply(1:n_sim, function(i) sim_results[[i]]$dose)
surv_time_obs <- sapply(1:n_sim, function(i) sim_results[[i]]$surv_time_obs)
tox_time_obs <- sapply(1:n_sim, function(i) sim_results[[i]]$tox_time_obs)
mb <- sapply(1:n_sim, function(i) sim_results[[i]]$mb)
output1 <- sapply(1:n_sim, function(i) ESTIMATORS(d.esl[,i], d.exp1[,i], t.esl[,i], t.exp1[,i], optimal_dose[i], dose[,i], surv_time_obs[,i], tox_time_obs[,i], mb[,i]))
output2 <- sapply(1:n_sim, function(i) ESTIMATORS(d.esl[,i], d.exp2[,i], t.esl[,i], t.exp2[,i], optimal_dose[i], dose[,i], surv_time_obs[,i], tox_time_obs[,i], mb[,i]))
# output3 <- sapply(1:n_sim, function(i) ESTIMATORS(d.esl[,i], d.exp3[,i], t.esl[,i], t.exp3[,i], optimal_dose[i], dose[,i], surv_time_obs[,i], tox_time_obs[,i], mb[,i]))
# output4 <- sapply(1:n_sim, function(i) ESTIMATORS(d.esl[,i], d.exp4[,i], t.esl[,i], t.exp4[,i], optimal_dose[i], dose[,i], surv_time_obs[,i], tox_time_obs[,i], mb[,i]))
return(list(output1 = output1, output2 = output2))
}
### Pacakges needed to be loaded
library(Hmisc) # For binconf (i.e. wilson binomial confidence intervals)
library(rjags)
library(parallel)  ####this needs to be parallel###
library(boot)
n_sim <- 1000
all_data <- 1
max_n <- 21
cohort_size <- 3
wait_time <- 2
dec_n <- 20
dose_level <- 1:4
surv_T <- 24
tox_T <- 4
a <- 1 # Shape 1 parameter for the beta distribution to simulate survival and toxicty time
>>>>>>> master
## Choose case ###
true.prob <- function(case){
if (case == 1){
b0t <- -3; b1t <- 1
b0s <- -0.5; b1s <- 0.7
} else if (case == 2){
b0t <- -0.5; b1t <- 0.6
b0s <- 1.2; b1s <- 0.3
}else if (case == 3){
b0t <- -3.5; b1t <- 0.9
b0s <- -2; b1s <- 0.9
} else if (case == 4) {
b0t <- -1; b1t <- 0.5
b0s <- -0.05; b1s <- 1.1
}
pt <- round(inv.logit(b0t + b1t*0:3), 2)
ps <- round(inv.logit(b0s + b1s*0:3), 2)
return(list(pt = pt, ps = ps))
}
<<<<<<< HEAD
###case 1###
#pt <- c(.05, .12, .27, .50) ###beta0 = -3, beta1 = 1###
#ps <- c(.38, .55, .71, .83) ###beta0 = -0.5, beta1 = 0.7###
###case 2###
##pt <- c(.38, .52, .67, .79) ###beta0 = -.5, beta1 = .6###
##ps <- c(.77, .82, .86, .89) ###beta0 = 1.2, beta1 = .3###
###case 3######
##pt <- c(.02, .07, .15, .31) ###beta0 = -3.5, beta1 = .9###
##ps <- c(.12, .25, .45, .67) ###beta0 = -2, beta1 = .9###
### case 4###
##pt <- c(0.27, 0.38,0.50, 0.62) ####beta0 = -1, beta1 = 0.5
##ps <- c(0.49, 0.74, 0.90, 0.96) #### beta0 = -0.05, beta = 1.1
###minimum efficacy and maximum toxicity###
=======
>>>>>>> master
ps_min <- .55
pt_max <- 0.50
ps_star <- .70
pt_star <- .40
<<<<<<< HEAD
###gatekeeper parameters###
gatekeeper <- .05
###hyperparameters###
###mean hyperparameters###
=======
gatekeeper <- .05
>>>>>>> master
beta0t_m <- -3
beta1t_m <- 1
beta0s_m <- -1
beta1s_m <- 1
beta2s_m <- 0
<<<<<<< HEAD
##psi_m <- .5
###sd hyperparameters###
beta0t_s <- 3
=======
>>>>>>> master
beta1t_s <- 2
beta0s_s <- 3
beta1s_s <- 2
beta2s_s <- 0.5
<<<<<<< HEAD
###translating hyperparameters for SD to precision###
=======
>>>>>>> master
beta0t_p <- 1/(beta0t_s^2)
beta1t_p <- 1/(beta1t_s^2)
beta0s_p <- 1/(beta0s_s^2)
beta1s_p <- 1/(beta1s_s^2)
beta2s_p <- 1/(beta2s_s^2)
<<<<<<< HEAD
###function to calculate desirability measure###
###calculate p using contour propossed by Thall and Cook###
find_p <- function(p) {
(((1 - ps_star)/(1 - ps_min)) ^ p + (pt_star / pt_max) ^ p - 1) ^ 2
}
p <- optimize(find_p, c(-100,100))$minimum
=======
find_p <- function(p) {
(((1 - ps_star) / (1 - ps_min)) ^ p + (pt_star / pt_max) ^ p - 1) ^ 2
}
p <- optimize(find_p, c(-100,100))$minimum
beta0t_s <- 3
beta1t_s <- 2
beta0s_s <- 3
beta1s_s <- 2
beta2s_s <- 0.5
beta0t_p <- 1/(beta0t_s^2)
beta1t_p <- 1/(beta1t_s^2)
beta0s_p <- 1/(beta0s_s^2)
beta1s_p <- 1/(beta1s_s^2)
beta2s_p <- 1/(beta2s_s^2)
>>>>>>> master
calc_dist <- function(ps, pt) {
dist <- 1 - (((1 - ps) / (1 - ps_min)) ^ p + (pt / pt_max) ^ p ) ^ (1 / p)
dist
}
<<<<<<< HEAD
############## DOSE EXPANSION COHORT #############
# PURPOSE: To simulate binary deaths and toxicity events based on the optimal dose found in
# the dose-finding algorithm and the true efficacy and toxicity values. Specifically,
# we simulate a follow-up cohort assuming no inter-trial heterogeneity, lower inter-trial
# heterogeneity, upper inter-trial heterogeneity, and inter-trial heterogeniety. (We add N(0,0.25)
# to the logit of the probability of toxcity and efficacy)
## INPUT:
# optimal_dose: The optimal dose obtained by the dose finding model
# case: case number to get respective efficacy and toxicity coefficents from the logistic model
## OUTPUT (list):
# d1: simulated DEC death outcomes for 20 subjects assuming no inter-trial heterogeneity
# t1: simulated DEC tox outcomes for 20 subjects assuming no inter-trial heterogeneity
# d2: simulated DEC death outcomes for 20 subjects assuming lower inter-trial heterogeneity
# t2: simulated DEC tox outcomes for 20 subjects assuming lower inter-trial heterogeneity
# ps.lwr: True efficacy value at the optimal dose assuming lower inter-trial heterogeneity
# pt.lwr: True efficacy value at the optimal dose assuming lower inter-trial heterogeneity
# d3: simulated DEC death outcomes for 20 subjects assuming upper inter-trial heterogeneity
# t3: simulated DEC tox outcomes for 20 subjects assuming upperinter-trial heterogeneity
# ps.upr: True efficacy value at the optimal dose assuming upper inter-trial heterogeneity
# pt.upr: True efficacy value at the optimal dose assuming upper inter-trial heterogeneity
# d4: simulated DEC death outcomes for 20 subjects assuming random inter-trial heterogeneity
# t4: simulated DEC tox outcomes for 20 subjects assuming random inter-trial heterogeneity
# ps.lwr: True efficacy value at the optimal dose assuming random inter-trial heterogeneity
# pt.lwr: True efficacy value at the optimal dose assuming random inter-trial heterogeneity
DEC <- function(optimal_dose, case){
# It optimal dose is zero (i.e. trial stopped), then return an empty list
if(optimal_dose != 0){
# IF else statment to call beta coefficents for the logistic model
if (case == 1){
b0t <- -3; b1t <- 1
b0s <- -0.5; b1s <- 0.7
} else if (case == 2){
b0t <- -0.5; b1t <- 0.6
b0s <- 1.2; b1s <- 0.3
}else if (case == 3){
b0t <- -3.5; b1t <- 0.9
b0s <- -2; b1s <- 0.9
} else if (case == 4) {
b0t <- -1; b1t <- 0.5
b0s <- -0.05; b1s <- 1.1
}
# The true values efficacy and toxicity (1. No inter-trial heterogeneity)
pt <- inv.logit(b0t + b1t*0:3)[optimal_dose]
ps <- inv.logit(b0s + b1s*0:3)[optimal_dose]
# Jitter the true values efficacy and toxicity (2. lower inter-trial heterogeneity)
pt.lwr <- inv.logit(b0t + b1t*0:3 - abs(rnorm(n = 1, sd = 0.25)))[optimal_dose]
ps.lwr <- inv.logit(b0s + b1s*0:3 - abs(rnorm(n = 1, sd = 0.25)))[optimal_dose]
# Jitter the true values efficacy and toxicity (3. upper inter-trial heterogeneity)
pt.upr <- inv.logit(b0t + b1t*0:3 + abs(rnorm(n = 1, sd = 0.25)))[optimal_dose]
ps.upr <- inv.logit(b0s + b1s*0:3 + abs(rnorm(n = 1, sd = 0.25)))[optimal_dose]
# Jitter the true values efficacy and toxicity (4. random inter-trial heterogeneity)
pt.ith <- inv.logit(b0t + b1t*0:3 + rnorm(n = 1, sd = 0.25))[optimal_dose]
ps.ith <- inv.logit(b0s + b1s*0:3 + rnorm(n = 1, sd = 0.25))[optimal_dose]
# Sampling 20 subjects toxicity based on true values of the optimal_dose
t1 <- rbinom(n = dec_n, size = 1, prob = pt)
t2 <- rbinom(n = dec_n, size = 1, prob = pt.lwr)
t3 <- rbinom(n = dec_n, size = 1, prob = pt.upr)
t4 <- rbinom(n = dec_n, size = 1, prob = pt.ith)
# Sampling 20 subjects death status based on true values of the optimal dose
d1 <- 1 - rbinom(n = dec_n, size = 1, prob = ps)
d2 <- 1 - rbinom(n = dec_n, size = 1, prob = ps.lwr)
d3 <- 1 - rbinom(n = dec_n, size = 1, prob = ps.upr)
d4 <- 1 - rbinom(n = dec_n, size = 1, prob = ps.ith)
} else {
d1 = t1 = d2 = t2  = d3 = t3 = d4 = t4 = rep(NA, dec_n)
ps.lwr = pt.lwr = ps.upr = pt.upr = ps.ith = pt.ith = NA
}
return(list(
d1     = d1,
t1     = t1,
d2     = d2,
t2     = t2,
ps.lwr = ps.lwr,
pt.lwr = pt.lwr,
d3     = d3,
t3     = t3,
ps.upr = ps.upr,
pt.upr = pt.upr,
d4     = d4,
t4     = t4,
ps.ith = ps.ith,
pt.ith = pt.ith))
}
# for debugging:
# debug(DEC)
# DEC(1, 3)
# DEC(4, 2)
##########################################################
############## Dose Escalation Clinical Trial #############
SurvEffTox_sim <- function(seed, ps, pt, case) {
set.seed(seed)
###starting values for week, dose and max dose###
cur_week <- 1
cur_dose <- 1
max_dose <- 1
###vectors for storing data###
dose      <- rep(NA, max_n)  ###dose###
surv      <- rep(NA, max_n)  ###survival at current time###
tox       <- rep(NA, max_n)  ###toxicity at current time###
surv_time <- rep(NA, max_n)  ###survival time###
tox_time  <- rep(NA, max_n)  ###toxicity time###
###week subject starts on trial - currently 1, 3, 5, etc. - this will change###
start_week <- cumsum(rexp(n = max_n, rate = 1/wait_time))
start_week <- start_week - start_week[1]
surv_mult <- rep(NA, max_n)  ###weight for survival outcome###
tox_mult  <- rep(1, max_n)   ###weight for toxicity outcome###
outcome   <- matrix(ncol = 4, nrow = max_n, data = NA)
X <- matrix(data = 0, nrow = max_n, ncol = 4)		###multinomial outcome###
stop_trial <- 0
total_subjects <- cohort_size
while(stop_trial == 0){
###assign current dose to current cohort###
dose[(total_subjects - cohort_size + 1):total_subjects] <- cur_dose
###simulate survival and toxicity time from uniform distribution - I'd like to try other distributions###
surv_time[(total_subjects - cohort_size + 1): total_subjects] <- surv_T * pmax(rbinom(n = cohort_size, size = 1, prob = ps[cur_dose]), rbeta(n = cohort_size, shape1 = a, shape2 = 1))
tox_time[(total_subjects - cohort_size + 1): total_subjects] <- tox_T * pmax((1 - rbinom(n = cohort_size, size = 1, prob = pt[cur_dose])), rbeta(n = cohort_size, shape1 = a, shape2 = 1))
###determined how many weeks each outcome has been observed - if all_data
if(total_subjects < max_n & all_data == 0) {
###determine week when next cohort will enter - this will change with stochastic enrollment time###
cur_week <- start_week[(total_subjects + 1)]
surv_u <- pmin(cur_week - start_week, surv_T)
tox_u <- pmin(cur_week - start_week, tox_T)
}else{
surv_u <- rep(surv_T, max_n)
tox_u <- rep(tox_T, max_n)
}
death <- 1*(surv_time < surv_u)
tox <- 1*(tox_time < tox_u)
surv_time_obs <- pmin(surv_time, surv_u)
tox_time_obs <- pmin(tox_time, tox_u)
##outcome[,1] <- 1 * (death == 1 & tox == 1)
##outcome[,2] <- 1 * (death == 1 & tox == 0)
##outcome[,3] <- 1 * (death == 0 & tox == 1)
##outcome[,4] <- 1 * (death == 0 & tox == 0)
scenario <- 1 * (death == 1 & tox == 1) + 2 * (death == 1 & tox == 0) + 3 * (death == 0 & tox == 1) + 4 * (death == 0 & tox == 0)
###update model###
jags_works <- 0
attempt <- 1
while(jags_works == 0) {
jags_mod <- try(jags.model('survEffTox_revision_unif2.bug',
data = list(
'scenario' = scenario[1:total_subjects],
'dose'     = dose[1:total_subjects],
'N'        = total_subjects,
'y_s'      = surv_time_obs[1:total_subjects],
'h_s'      = surv_T,
'y_t'      = tox_time_obs[1:total_subjects],
'h_t'      = tox_T,
'beta0t_m' = beta0t_m,
'beta1t_m' = beta1t_m,
'beta0s_m' = beta0s_m,
'beta1s_m' = beta1s_m,
'beta2s_m' = beta2s_m,
'beta0t_p' = beta0t_p,
'beta1t_p' = beta1t_p,
'beta0s_p' = beta0s_p,
'beta1s_p' = beta1s_p,
'beta2s_p' = beta2s_p,
'ones'     = rep(1, total_subjects)),
init = list(
'beta0t' = -2,
'beta1t' = 1,
'beta0s' = -1,
'beta1s' = 1,
'beta2s' = 0),
n.chains = 1, quiet = TRUE))
jags_works <- 1*(length(jags_mod) > 1 | attempt == 10)
attempt <- attempt + 1
}
update(jags_mod, 4000, quiet = TRUE)
coda_samples_temp <- coda.samples(jags_mod, c('pt_est', 'ps_est'), 1000, quiet = TRUE)
##coda_samples_temp <- coda.samples(jags_mod, c('pt_est', 'ps_est', 'beta0t', 'beta1t', 'beta0s', 'beta1s', 'beta2s'), 1000)
coda_samples <- coda_samples_temp[[1]]
dist_samples <- matrix(data = 0, ncol = dim(coda_samples)[2]/2, nrow = dim(coda_samples)[1])
for(k in 1:dim(dist_samples)[2]) {
dist_samples[,k] <- calc_dist(ps = coda_samples[,k], pt = coda_samples[,(k + 4)])
}
###prob_ps_g_psmin is the posterior probability that the probability of survival is greater than ps_min###
###prob_pt_l_ptmax is the posterior probability that the probability of toxicity is less than pt_max###
prob_acceptable <- colMeans(dist_samples > 0)
###determine acceptable doses###
acceptable <- 1*(prob_acceptable > gatekeeper)
accept_dose <- dose_level[acceptable  == 1]
###stop trial if all doses are unacceptable###
###otherwise, calculate desirability index for acceptable doses###
if(sum(acceptable) == 0) {
stop_trial <- 1
cur_dose <- 0
} else {
ps_cur <- colMeans(coda_samples[,1:4])
pt_cur <- colMeans(coda_samples[,5:8])
dist_cur <- calc_dist(ps_cur[acceptable  == 1], pt_cur[acceptable  == 1])
###identify best dose and update current dose###
best_dose <- accept_dose[which.max(dist_cur)]
cur_dose <- min(best_dose, max_dose + 1)
max_dose <- max(max_dose, cur_dose)
stop_trial <- total_subjects >= max_n
}
###update max dose###
total_subjects <- total_subjects + cohort_size
}
## If trial stopped (doses unacceptable), then set optimal dose to zero.
## Otherwise, set the best dose as the new optimal dose
if(sum(acceptable) == 0){
optimal_dose <- 0
} else {
optimal_dose <- best_dose
}
## indicator of whether or not outcomes are treated as time-to-event variables
## all_data = 0 implies time-to-event, all_data = 1 implies binary outcomes
if(all_data == 0) {
study_duration <- max(pmax(pmin(surv_time[1:(total_subjects - cohort_size)], surv_T), pmin(tox_time[1:(total_subjects - cohort_size)], tox_T)) + start_week[1:(total_subjects - cohort_size)])
}
if(all_data == 1) {
for(i in 1:max(((total_subjects/cohort_size) - 2),1) ){
earliest_start <- max(pmax(pmin(surv_time[((i - 1) * cohort_size + 1):(i * cohort_size)], surv_T), pmin(tox_time[((i - 1) * cohort_size + 1):(i * cohort_size)], tox_T)) + start_week[((i - 1) * cohort_size + 1):(i * cohort_size)])
start_week[(i * cohort_size + 1):(i * cohort_size + cohort_size)] <- pmax(start_week[(i * cohort_size + 1):(i * cohort_size + cohort_size)], earliest_start)
}
study_duration <- max(pmax(pmin(surv_time[1:(total_subjects - cohort_size)], surv_T), pmin(tox_time[1:(total_subjects - cohort_size)], tox_T)) + start_week[1:(total_subjects - cohort_size)])
}
## Simulate the follow-up cohort based on the optimal dose found by the dose-finding model
## using the function DEC directly in the returned list. Four situations will be outputed (See DEC function)
## Create list of data from dose finding model
dat <- c(optimal_dose, sum(dose == 1, na.rm = T), sum(dose == 2, na.rm = T), sum(dose == 3, na.rm = T), sum(dose == 4, na.rm = T), study_duration)
# model based estimates
s.mb <- ps_cur[optimal_dose]
t.mb <- pt_cur[optimal_dose]
s.mb_conf <- quantile(coda_samples[,optimal_dose], prob = c(0.025, 0.975))
t.mb_conf <- quantile(coda_samples[,(optimal_dose +4)], prob = c(0.025, 0.975))
if(optimal_dose == 0){s.mb = t.mb = NA;  s.mb_conf = t.mb_conf = rep(NA, 2)}
mb <- c(s.mb, s.mb_conf, t.mb, t.mb_conf)
out <- list(
dat           = dat,
death         = death,
tox           = tox,
dec           = DEC(optimal_dose, case),
dose          = dose,
surv_time_obs = surv_time_obs,
tox_time_obs  = tox_time_obs,
mb            = mb)
out
}
# for debugging
# debug(SurvEffTox_sim)
# ps <- true.prob(case = 1)$ps
# pt <- true.prob(case = 1)$pt
# SurvEffTox_sim()
## START SIMULATION
# SET SEEED FOR REPLICATION
RNGkind("L'Ecuyer-CMRG")
set.seed(7777442)
# Set number of cores for parallel
# **Set to one core but can be changed**
no_cores <- detectCores()-7
# start.time <- Sys.time()
# end.time <- Sys.time()
# end.time-start.time
# Simulation for Case 1
# ps <- true.prob(case = 1)$ps
# pt <- true.prob(case = 1)$pt
SurvEffTox_sim()
SurvEffTox_sim(1)
SurvEffTox_sim(1, true.prob(case = 1)$ps)
SurvEffTox_sim(1, true.prob(case = 1)$ps, true.prob(case = 1)$pt)
SurvEffTox_sim(1, true.prob(case = 1)$ps, true.prob(case = 1)$pt, case)
SurvEffTox_sim(1, true.prob(case = 1)$ps, true.prob(case = 1)$pt, 1)
no_cores
formals(mclapply)
getwd()
SurvEffTox_sim <- function(seed, ps, pt, case) {
set.seed(seed)
###starting values for week, dose and max dose###
cur_week <- 1
cur_dose <- 1
max_dose <- 1
###vectors for storing data###
dose      <- rep(NA, max_n)  ###dose###
surv      <- rep(NA, max_n)  ###survival at current time###
tox       <- rep(NA, max_n)  ###toxicity at current time###
surv_time <- rep(NA, max_n)  ###survival time###
tox_time  <- rep(NA, max_n)  ###toxicity time###
###week subject starts on trial - currently 1, 3, 5, etc. - this will change###
start_week <- cumsum(rexp(n = max_n, rate = 1/wait_time))
start_week <- start_week - start_week[1]
surv_mult <- rep(NA, max_n)  ###weight for survival outcome###
tox_mult  <- rep(1, max_n)   ###weight for toxicity outcome###
outcome   <- matrix(ncol = 4, nrow = max_n, data = NA)
X <- matrix(data = 0, nrow = max_n, ncol = 4)		###multinomial outcome###
stop_trial <- 0
total_subjects <- cohort_size
while(stop_trial == 0){
###assign current dose to current cohort###
dose[(total_subjects - cohort_size + 1):total_subjects] <- cur_dose
###simulate survival and toxicity time from uniform distribution - I'd like to try other distributions###
surv_time[(total_subjects - cohort_size + 1): total_subjects] <- surv_T * pmax(rbinom(n = cohort_size, size = 1, prob = ps[cur_dose]), rbeta(n = cohort_size, shape1 = a, shape2 = 1))
tox_time[(total_subjects - cohort_size + 1): total_subjects] <- tox_T * pmax((1 - rbinom(n = cohort_size, size = 1, prob = pt[cur_dose])), rbeta(n = cohort_size, shape1 = a, shape2 = 1))
###determined how many weeks each outcome has been observed - if all_data
if(total_subjects < max_n & all_data == 0) {
###determine week when next cohort will enter - this will change with stochastic enrollment time###
cur_week <- start_week[(total_subjects + 1)]
surv_u <- pmin(cur_week - start_week, surv_T)
tox_u <- pmin(cur_week - start_week, tox_T)
}else{
surv_u <- rep(surv_T, max_n)
tox_u <- rep(tox_T, max_n)
}
death <- 1*(surv_time < surv_u)
tox <- 1*(tox_time < tox_u)
surv_time_obs <- pmin(surv_time, surv_u)
tox_time_obs <- pmin(tox_time, tox_u)
##outcome[,1] <- 1 * (death == 1 & tox == 1)
##outcome[,2] <- 1 * (death == 1 & tox == 0)
##outcome[,3] <- 1 * (death == 0 & tox == 1)
##outcome[,4] <- 1 * (death == 0 & tox == 0)
scenario <- 1 * (death == 1 & tox == 1) + 2 * (death == 1 & tox == 0) + 3 * (death == 0 & tox == 1) + 4 * (death == 0 & tox == 0)
###update model###
jags_works <- 0
attempt <- 1
while(jags_works == 0) {
jags_mod <- try(jags.model('survEffTox_revision_unif2.bug',
data = list(
'scenario' = scenario[1:total_subjects],
'dose'     = dose[1:total_subjects],
'N'        = total_subjects,
'y_s'      = surv_time_obs[1:total_subjects],
'h_s'      = surv_T,
'y_t'      = tox_time_obs[1:total_subjects],
'h_t'      = tox_T,
'beta0t_m' = beta0t_m,
'beta1t_m' = beta1t_m,
'beta0s_m' = beta0s_m,
'beta1s_m' = beta1s_m,
'beta2s_m' = beta2s_m,
'beta0t_p' = beta0t_p,
'beta1t_p' = beta1t_p,
'beta0s_p' = beta0s_p,
'beta1s_p' = beta1s_p,
'beta2s_p' = beta2s_p,
'ones'     = rep(1, total_subjects)),
init = list(
'beta0t' = -2,
'beta1t' = 1,
'beta0s' = -1,
'beta1s' = 1,
'beta2s' = 0),
n.chains = 1, quiet = TRUE))
jags_works <- 1*(length(jags_mod) > 1 | attempt == 10)
attempt <- attempt + 1
}
update(jags_mod, 4000, quiet = TRUE)
coda_samples_temp <- coda.samples(jags_mod, c('pt_est', 'ps_est'), 1000, quiet = TRUE)
##coda_samples_temp <- coda.samples(jags_mod, c('pt_est', 'ps_est', 'beta0t', 'beta1t', 'beta0s', 'beta1s', 'beta2s'), 1000)
coda_samples <- coda_samples_temp[[1]]
dist_samples <- matrix(data = 0, ncol = dim(coda_samples)[2]/2, nrow = dim(coda_samples)[1])
for(k in 1:dim(dist_samples)[2]) {
dist_samples[,k] <- calc_dist(ps = coda_samples[,k], pt = coda_samples[,(k + 4)])
}
###prob_ps_g_psmin is the posterior probability that the probability of survival is greater than ps_min###
###prob_pt_l_ptmax is the posterior probability that the probability of toxicity is less than pt_max###
prob_acceptable <- colMeans(dist_samples > 0)
###determine acceptable doses###
acceptable <- 1*(prob_acceptable > gatekeeper)
accept_dose <- dose_level[acceptable  == 1]
###stop trial if all doses are unacceptable###
###otherwise, calculate desirability index for acceptable doses###
if(sum(acceptable) == 0) {
stop_trial <- 1
cur_dose <- 0
} else {
ps_cur <- colMeans(coda_samples[,1:4])
pt_cur <- colMeans(coda_samples[,5:8])
dist_cur <- calc_dist(ps_cur[acceptable  == 1], pt_cur[acceptable  == 1])
###identify best dose and update current dose###
best_dose <- accept_dose[which.max(dist_cur)]
cur_dose <- min(best_dose, max_dose + 1)
max_dose <- max(max_dose, cur_dose)
stop_trial <- total_subjects >= max_n
}
###update max dose###
total_subjects <- total_subjects + cohort_size
}
## If trial stopped (doses unacceptable), then set optimal dose to zero.
## Otherwise, set the best dose as the new optimal dose
if(sum(acceptable) == 0){
optimal_dose <- 0
} else {
optimal_dose <- best_dose
}
## indicator of whether or not outcomes are treated as time-to-event variables
## all_data = 0 implies time-to-event, all_data = 1 implies binary outcomes
if(all_data == 0) {
study_duration <- max(pmax(pmin(surv_time[1:(total_subjects - cohort_size)], surv_T), pmin(tox_time[1:(total_subjects - cohort_size)], tox_T)) + start_week[1:(total_subjects - cohort_size)])
}
if(all_data == 1) {
for(i in 1:max(((total_subjects/cohort_size) - 2),1) ){
earliest_start <- max(pmax(pmin(surv_time[((i - 1) * cohort_size + 1):(i * cohort_size)], surv_T), pmin(tox_time[((i - 1) * cohort_size + 1):(i * cohort_size)], tox_T)) + start_week[((i - 1) * cohort_size + 1):(i * cohort_size)])
start_week[(i * cohort_size + 1):(i * cohort_size + cohort_size)] <- pmax(start_week[(i * cohort_size + 1):(i * cohort_size + cohort_size)], earliest_start)
}
study_duration <- max(pmax(pmin(surv_time[1:(total_subjects - cohort_size)], surv_T), pmin(tox_time[1:(total_subjects - cohort_size)], tox_T)) + start_week[1:(total_subjects - cohort_size)])
}
## Simulate the follow-up cohort based on the optimal dose found by the dose-finding model
## using the function DEC directly in the returned list. Four situations will be outputed (See DEC function)
## Create list of data from dose finding model
dat <- c(optimal_dose, sum(dose == 1, na.rm = T), sum(dose == 2, na.rm = T), sum(dose == 3, na.rm = T), sum(dose == 4, na.rm = T), study_duration)
# model based estimates
s.mb <- ps_cur[optimal_dose]
t.mb <- pt_cur[optimal_dose]
s.mb_conf <- quantile(coda_samples[,optimal_dose], prob = c(0.025, 0.975))
t.mb_conf <- quantile(coda_samples[,(optimal_dose +4)], prob = c(0.025, 0.975))
if(optimal_dose == 0){s.mb = t.mb = NA;  s.mb_conf = t.mb_conf = rep(NA, 2)}
mb <- c(s.mb, s.mb_conf, t.mb, t.mb_conf)
out <- list(
dat           = dat,
death         = death,
tox           = tox,
dec           = DEC(optimal_dose, case),
dose          = dose,
surv_time_obs = surv_time_obs,
tox_time_obs  = tox_time_obs,
mb            = mb)
out
}
=======
beta0t_m <- -3
beta1t_m <- 1
beta0s_m <- -1
beta1s_m <- 1
beta2s_m <- 0
beta0t_s <- 3
beta1t_s <- 2
beta0s_s <- 3
beta1s_s <- 2
beta2s_s <- 0.5
beta0t_p <- 1/(beta0t_s^2)
beta1t_p <- 1/(beta1t_s^2)
beta0s_p <- 1/(beta0s_s^2)
beta1s_p <- 1/(beta1s_s^2)
beta2s_p <- 1/(beta2s_s^2)
find_p <- function(p) {
(((1 - ps_star) / (1 - ps_min)) ^ p + (pt_star / pt_max) ^ p - 1) ^ 2
}
p <- optimize(find_p, c(-100,100))$minimum
calc_dist <- function(ps, pt) {
dist <- 1 - (((1 - ps) / (1 - ps_min)) ^ p + (pt / pt_max) ^ p ) ^ (1 / p)
dist
}
# ~~~ for debugging ~~~ ----
debug(EstiResults)
debug(Pool)
debug(DOSE.MODEL)
debug(BetaComP)
debug(ESTIMATORS)
load('RData/sim_results1.RData')
>>>>>>> master
